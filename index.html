<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Track Apex</title>
    
    <!-- Polices Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Intégration de Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Configuration du thème Tailwind CSS "Pro Sim" -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Poppins', 'sans-serif'],
                        'mono': ['Roboto Mono', 'monospace'],
                    },
                    colors: {
                        'background': '#101010', // Gris très sombre
                        'surface': '#1E1E1E',   // Gris pour les surfaces
                        'primary': '#007BFF',   // Bleu électrique
                        'muted': '#808080',    // Gris pour texte secondaire
                        'border-color': '#333333', // Couleur de bordure subtile
                        'accent-red': '#EF4444',
                        'accent-orange': '#F97316',
                        'accent-yellow': '#EAB308',
                        'accent-green': '#22C55E',
                    },
                    keyframes: {
                        pulse: {
                            '0%, 100%': { transform: 'scale(1)', boxShadow: '0 0 0 0 rgba(0, 123, 255, 0.7)' },
                            '50%': { transform: 'scale(1.05)', boxShadow: '0 0 0 10px rgba(0, 123, 255, 0)' },
                        }
                    },
                    animation: {
                        pulse: 'pulse 2s infinite',
                    }
                }
            }
        }
    </script>

    <!-- Style CSS additionnel pour le thème -->
    <style type="text/tailwindcss">
        @layer base {
            body { @apply bg-background text-gray-300 font-sans; }
            h1, h2, h3, h4, h5, h6 { @apply font-sans font-semibold tracking-wide text-white; }
            ::-webkit-scrollbar { width: 6px; }
            ::-webkit-scrollbar-track { background: transparent; }
            ::-webkit-scrollbar-thumb { @apply bg-muted/30 rounded-full; }
            ::-webkit-scrollbar-thumb:hover { @apply bg-primary/50; }
            .btn { @apply font-semibold py-2 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background text-sm; }
            .btn-primary { @apply bg-primary text-white hover:bg-blue-400 focus:ring-primary; }
            .btn-secondary { @apply bg-surface text-gray-300 hover:bg-gray-700/80 border border-border-color focus:ring-muted; }
            .btn-danger { @apply bg-red-600/10 text-red-400 border border-red-600/30 hover:bg-red-600/30 hover:text-red-300 focus:ring-red-500; }
            .placing-marker-mode { cursor: crosshair; }
            .octagon {
                clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            }
        }
    </style>
    
    <!-- SDK Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-storage-compat.js"></script>
</head>

<body class="overflow-hidden h-screen flex flex-col antialiased">

    <!-- En-tête -->
    <header class="bg-surface/50 backdrop-blur-sm p-4 flex justify-between items-center z-30 shrink-0 border-b border-border-color">
        <h1 class="text-xl tracking-widest uppercase font-mono">Track Apex</h1>
        <div id="main-controls" class="flex items-center gap-6 invisible">
            <button id="summary-btn" class="btn btn-secondary">Résumé</button>
            <div id="global-view-toggle" class="flex items-center gap-3 cursor-pointer select-none">
                <span class="font-semibold text-sm uppercase text-gray-400">Vue Globale</span>
                <div class="toggle-bg w-12 h-6 flex items-center bg-gray-700 rounded-full p-1 duration-300 ease-in-out">
                    <div class="bg-white w-4 h-4 rounded-full shadow-md transform duration-300 ease-in-out"></div>
                </div>
            </div>
        </div>
    </header>

    <!-- Corps principal -->
    <div class="flex flex-1 overflow-hidden">
        <!-- Barre latérale -->
        <aside id="sidebar" class="bg-surface/20 w-80 p-5 flex flex-col space-y-6 shrink-0 border-r border-border-color">
            <div>
                <h2 class="text-lg mb-3">Circuits</h2>
                <button id="new-circuit-btn" class="btn btn-primary w-full">+ Nouveau Circuit</button>
            </div>
            <div id="circuits-list" class="flex-1 overflow-y-auto space-y-2 pr-2 -mr-2"></div>
            <div id="turn-controls-wrapper" class="hidden border-t border-border-color pt-6 space-y-4">
                <button id="edit-turns-btn" class="btn btn-secondary w-full">Modifier les Virages</button>
                <div id="toolbox" class="hidden">
                    <div id="active-turn-display" class="mb-4 text-center p-3 bg-black/30 rounded-lg border border-border-color"></div>
                    <div id="toolbox-grid" class="grid grid-cols-2 gap-3"></div>
                </div>
            </div>
        </aside>

        <!-- Zone principale de la carte -->
        <main id="map-container" class="flex-1 bg-black flex items-center justify-center p-4 relative overflow-hidden">
            <div id="map-wrapper" class="relative w-full h-full select-none">
                <img id="circuit-image" class="hidden w-full h-full object-contain pointer-events-none"/>
                <div id="markers-layer" class="absolute top-0 left-0 w-full h-full"></div>
                <div id="tooltip" class="hidden absolute bg-surface/90 text-white text-sm rounded-md p-2 border border-primary pointer-events-none z-40 max-w-xs backdrop-blur-sm"></div>
            </div>
            <div id="welcome-message" class="text-center">
                <h2 class="text-2xl">Bienvenue sur Track Apex</h2>
                <p class="text-muted mt-2">Sélectionnez un circuit ou créez-en un nouveau pour commencer.</p>
            </div>
        </main>
    </div>

    <!-- Modales -->
    <div id="modal-backdrop" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-40 hidden flex items-center justify-center p-4">

        <!-- Modale Nouveau Circuit -->
        <div id="modal-new-circuit" class="modal-content bg-surface p-8 rounded-xl shadow-2xl w-full max-w-md hidden border border-border-color">
            <h2 class="text-2xl mb-6">Nouveau Circuit</h2>
            <form id="form-new-circuit" class="space-y-4">
                <input type="text" id="circuit-name" placeholder="Nom du circuit" class="w-full bg-background p-3 rounded-lg border border-border-color focus:border-primary focus:ring-primary/50 focus:ring-1 outline-none" required>
                <input type="file" id="circuit-image-upload" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-gray-700 file:text-white hover:file:bg-primary hover:file:text-black cursor-pointer" required>
                <div class="flex justify-end gap-4 pt-4">
                    <button type="button" class="btn-cancel btn btn-secondary">Annuler</button>
                    <button type="submit" class="btn btn-primary">Sauvegarder</button>
                </div>
            </form>
        </div>

        <!-- Modale Repères -->
        <div id="modal-marker" class="modal-content bg-surface p-8 rounded-xl shadow-2xl w-full max-w-md hidden border border-border-color">
            <h2 id="marker-modal-title" class="text-2xl mb-6"></h2>
            <div id="marker-modal-content" class="space-y-4"></div>
            <textarea id="marker-notes" placeholder="Notes spécifiques (optionnel)..." class="w-full mt-6 bg-background p-3 rounded-lg border border-border-color h-24 resize-none focus:border-primary focus:ring-primary/50 focus:ring-1 outline-none"></textarea>
            <div class="flex justify-between mt-6">
                <button id="btn-delete-marker" class="btn btn-danger">Supprimer</button>
                <div class="flex gap-4">
                    <button type="button" class="btn-cancel btn btn-secondary">Annuler</button>
                    <button id="btn-save-marker" class="btn btn-primary">OK</button>
                </div>
            </div>
        </div>

        <!-- Modale Résumé -->
        <div id="modal-summary" class="modal-content bg-surface p-8 rounded-xl shadow-2xl w-full max-w-3xl h-5/6 flex flex-col hidden border border-border-color">
            <h2 class="text-2xl mb-6">Résumé du Circuit</h2>
            <div id="summary-content" class="flex-1 overflow-y-auto bg-background p-4 rounded-lg border border-border-color space-y-6"></div>
            <div class="flex justify-end mt-6">
                <button type="button" class="btn-cancel btn btn-primary">Fermer</button>
            </div>
        </div>
    </div>


    <script type="module">
        // ===================================================================================
        // --- 1. CONFIGURATION FIREBASE & AUTHENTIFICATION ---
        // ===================================================================================

        const firebaseConfig = {
            apiKey: "AIzaSyBjNSWsvjBrrYhp4WbJ3eKTV8_xxJB13OU",
            authDomain: "apexnote-ae9c5.firebaseapp.com",
            projectId: "apexnote-ae9c5",
            storageBucket: "apexnote-ae9c5.firebasestorage.app",
            messagingSenderId: "142592305791",
            appId: "1:142592305791:web:f8d73d4383474441abed4a"
        };

        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();
        
        async function connectAnonymously() {
            try {
                const userCredential = await auth.signInAnonymously();
                console.log("Firebase Connected with UID:", userCredential.user.uid);
                return userCredential.user.uid;
            } catch (error) {
                console.error("Anonymous Auth Error:", error);
                alert("Erreur critique de connexion à la base de données. L'application ne peut pas démarrer. Veuillez vérifier la console pour plus de détails.");
                return null;
            }
        }
        
        // ===================================================================================
        // --- 2. GESTION DE L'ÉTAT DE L'APPLICATION (STATE) ---
        // ===================================================================================

        const AppState = {
            userId: null,
            circuits: [],
            allNotes: {},
            activeCircuitId: null,
            activeTurnIndex: null,
            isPlacingTurns: false,
            isGlobalView: false,
            isDragging: false,
            placingMarkerType: null,
            editingMarkerInfo: null, 

            _listeners: [],

            setState(newState) {
                Object.assign(this, newState);
                console.log("State Updated:", this);
                this._listeners.forEach(listener => listener());
            },

            onChange(listener) { this._listeners.push(listener); },
            getActiveCircuit() { return this.circuits.find(c => c.id === this.activeCircuitId); }
        };

        // ===================================================================================
        // --- 3. FONCTIONS D'INTERACTION AVEC FIREBASE (API) ---
        // ===================================================================================
        
        const FirebaseAPI = {
            async createCircuit(name, imageFile) {
                if (!AppState.userId) throw new Error("User not authenticated.");
                const docRef = db.collection("circuits").doc();
                const imagePath = `circuits/${AppState.userId}/${docRef.id}/${imageFile.name}`;
                const storageRef = storage.ref(imagePath);
                
                await storageRef.put(imageFile);
                const imageUrl = await storageRef.getDownloadURL();

                const newCircuit = {
                    id: docRef.id,
                    userId: AppState.userId,
                    name,
                    imageUrl,
                    turns: [],
                };
                await docRef.set(newCircuit);
                return newCircuit;
            },

            async getUserCircuits() {
                if (!AppState.userId) throw new Error("User not authenticated.");
                const snapshot = await db.collection("circuits").where("userId", "==", AppState.userId).get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            },

            updateCircuitTurns(circuitId, turns) {
                return db.collection("circuits").doc(circuitId).update({ turns });
            },

            _getNoteDocId(circuitId, turnIndex) { return `${AppState.userId}_${circuitId}_${turnIndex}`; },
            
            async getAllNotesForCircuit(circuitId) {
                if (!AppState.userId) return {};
                const snapshot = await db.collection("notes")
                    .where("userId", "==", AppState.userId)
                    .where("circuitId", "==", circuitId)
                    .get();
                const notes = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    notes[data.turnIndex] = data;
                });
                return notes;
            },

            async updateTurnNote(circuitId, turnIndex, noteData) {
                const noteId = this._getNoteDocId(circuitId, turnIndex);
                const noteRef = db.collection("notes").doc(noteId);
                const existingNote = (await noteRef.get()).data() || {};
                
                const payload = {
                    ...existingNote,
                    userId: AppState.userId,
                    circuitId,
                    turnIndex,
                    ...noteData
                };
                return noteRef.set(payload, { merge: true });
            },

            async deleteMarkerFromNote(circuitId, turnIndex, markerType) {
                const noteId = this._getNoteDocId(circuitId, turnIndex);
                return db.collection("notes").doc(noteId).update({
                    [markerType]: firebase.firestore.FieldValue.delete()
                });
            }
        };

        // ===================================================================================
        // --- 4. LOGIQUE D'INTERFACE UTILISATEUR (UI) ---
        // ===================================================================================
        
        const DOMElements = {
            mainControls: document.getElementById('main-controls'),
            newCircuitBtn: document.getElementById('new-circuit-btn'),
            circuitsList: document.getElementById('circuits-list'),
            turnControlsWrapper: document.getElementById('turn-controls-wrapper'),
            toolbox: document.getElementById('toolbox'),
            activeTurnDisplay: document.getElementById('active-turn-display'),
            toolboxGrid: document.getElementById('toolbox-grid'),
            mapWrapper: document.getElementById('map-wrapper'),
            circuitImage: document.getElementById('circuit-image'),
            markersLayer: document.getElementById('markers-layer'),
            welcomeMessage: document.getElementById('welcome-message'),
            editTurnsBtn: document.getElementById('edit-turns-btn'),
            globalViewToggle: document.getElementById('global-view-toggle'),
            summaryBtn: document.getElementById('summary-btn'),
            tooltip: document.getElementById('tooltip'),
            modalBackdrop: document.getElementById('modal-backdrop'),
            newCircuitModal: document.getElementById('modal-new-circuit'),
            formNewCircuit: document.getElementById('form-new-circuit'),
            markerModal: document.getElementById('modal-marker'),
            markerModalTitle: document.getElementById('marker-modal-title'),
            markerModalContent: document.getElementById('marker-modal-content'),
            markerNotesTextarea: document.getElementById('marker-notes'),
            summaryModal: document.getElementById('modal-summary'),
            summaryContent: document.getElementById('summary-content'),
            btnSaveMarker: document.getElementById('btn-save-marker'),
            btnDeleteMarker: document.getElementById('btn-delete-marker'),
        };

        const markerIcons = {
            braking: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"/></svg>`,
            throttle: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12.6,2.2c-0.2-0.2-0.5-0.3-0.8-0.2C9.5,2.6,8,4.7,8,7.1c0,2.1,1.2,4.6,2.6,6.4c-2.5,1.1-4.2,3.6-4.2,6.4c0,0.8,0.7,1.5,1.5,1.5c0.5,0,0.9-0.2,1.2-0.6c0.9-1,2.2-1.6,3.6-1.6s2.7,0.6,3.6,1.6c0.3,0.3,0.7,0.6,1.2,0.6c0.8,0,1.5-0.7,1.5-1.5c0-2.8-1.7-5.3-4.2-6.4C14.8,11.7,16,9.2,16,7.1c0-2.4-1.5-4.5-3.8-5.1C12.1,2,12.2,2.1,12.6,2.2z"/></svg>`,
            gear: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20.94c1.5 0 2.75 1.06 2.75 2.38 0 .5-.16.98-.44 1.38l-.06.09a3.37 3.37 0 0 1-5.5 0l-.06-.09a2.46 2.46 0 0 1-.44-1.38C8.25 22 9.5 20.94 11 20.94h2Z"></path><path d="M12 2.06c-1.5 0-2.75-1.06-2.75-2.38 0-.5.16-.98.44-1.38l.06-.09a3.37 3.37 0 0 1 5.5 0l.06.09c.28.4.44.88.44 1.38 0 1.32-1.25 2.38-2.75 2.38h-2Z"></path><path d="M12 2.06V20.94"></path></svg>`,
            turn_in: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`,
            apex: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>`,
            exit: `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></svg>`,
        };

        const markerTypes = {
            braking: { label: "Freinage"},
            throttle: { label: "Remise Gaz"},
            gear: { label: "Rapport"},
            turn_in: { label: "Déclenchement"},
            apex: { label: "Corde"},
            exit: { label: "Sortie"}
        };

        const intensityLabels = {
            braking: { 4: 'Très Fort', 3: 'Fort', 2: 'Léger', 1: 'Pas de frein' },
            throttle: { 3: 'À fond', 2: 'Gaz moyen', 1: 'Filet de gaz' },
        };
        
        const UI = {
            showModal(modalElement) {
                DOMElements.modalBackdrop.classList.remove('hidden');
                modalElement.classList.remove('hidden');
            },
            hideAllModals() {
                DOMElements.modalBackdrop.classList.add('hidden');
                DOMElements.modalBackdrop.querySelectorAll('.modal-content').forEach(modal => modal.classList.add('hidden'));
            },

            renderCircuitsList() {
                const { circuits, activeCircuitId } = AppState;
                DOMElements.circuitsList.innerHTML = circuits.map(c => `
                    <div class="circuit-item p-3 rounded-lg cursor-pointer transition-colors relative ${c.id === activeCircuitId ? 'bg-primary/10 text-primary font-semibold' : 'bg-surface/50 hover:bg-gray-800/80'}" data-id="${c.id}">
                        ${c.id === activeCircuitId ? '<div class="absolute left-0 top-0 bottom-0 w-1 bg-primary rounded-r-full"></div>' : ''}
                        <span class="ml-3">${c.name}</span>
                    </div>`).join('');
            },

            renderActiveCircuit() {
                const circuit = AppState.getActiveCircuit();
                DOMElements.mainControls.classList.toggle('invisible', !circuit);
                DOMElements.turnControlsWrapper.classList.toggle('hidden', !circuit);
                DOMElements.welcomeMessage.classList.toggle('hidden', !!circuit);
                DOMElements.circuitImage.classList.toggle('hidden', !circuit);
                if (circuit) DOMElements.circuitImage.src = circuit.imageUrl;
            },
            
            renderToolbox() {
                DOMElements.toolboxGrid.innerHTML = Object.entries(markerTypes).map(([key, {label}]) => `
                    <button class="toolbox-item btn text-left flex items-center gap-3 ${AppState.placingMarkerType === key ? 'bg-primary text-white' : 'btn-secondary'}" data-type="${key}">
                        <span class="w-5 h-5">${markerIcons[key] || ''}</span>
                        <span class="flex-1">${label}</span>
                    </button>
                `).join('');
            },

            getMarkerColorClass(type, value) {
                const colorMap = {
                    braking: { 1: 'text-accent-green', 2: 'text-accent-yellow', 3: 'text-accent-orange', 4: 'text-accent-red' },
                    throttle: { 1: 'text-accent-green', 2: 'text-accent-yellow', 3: 'text-accent-red' },
                    turn_in: 'text-accent-orange',
                    apex: 'text-accent-red',
                    exit: 'text-accent-green',
                };
                return colorMap[type]?.[value] || colorMap[type] || 'text-primary';
            },
            
            createMarkerHTML(marker) {
                const { type, x, y, value, turnIndex, isActive, isGlobal, isPlacing } = marker;
                let content = '', size = 'w-9 h-9', style = '', customClasses = '';

                if (type === 'turn') {
                    content = `<span class="font-mono text-lg text-white">${value}</span>`;
                    style = `bg-surface border-2 rounded-full ${isActive ? 'border-primary' : 'border-border-color'}`;
                    if(isPlacing) customClasses = 'ring-4 ring-primary animate-pulse';
                } else {
                    size = 'w-8 h-8';
                    const colorClass = this.getMarkerColorClass(type, value);
                    
                    if (type === 'gear') {
                        style = 'bg-gray-800 octagon';
                        content = `<span class="font-mono font-bold text-white text-base">${value || '?'}</span>`;
                    } else if (type === 'braking' || type === 'throttle') {
                        // CORRECTION: Icônes dont la couleur de remplissage change
                        style = `rounded-full ${colorClass}`;
                        content = `<div class="p-1.5">${markerIcons[type]}</div>`;
                    }
                    else {
                         // Icônes avec fond coloré et icône blanche
                         const bgClass = colorClass.replace('text-', 'bg-');
                         style = `rounded-full ${bgClass}`;
                         content = `<div class="text-white p-1.5">${markerIcons[type]}</div>`;
                    }
                }
                
                const opacity = (!isActive && !isGlobal && type !== 'turn') ? 'opacity-20' : 'opacity-100';

                return `<div class="marker absolute ${size} ${style} ${opacity} ${customClasses} flex items-center justify-center shadow-lg cursor-pointer transform -translate-x-1/2 -translate-y-1/2 transition-all duration-200" 
                    style="left: ${x}%; top: ${y}%;"
                    data-type="${type}" data-turn-index="${turnIndex}">
                    ${content}
                </div>`;
            },

            renderMarkers() {
                const circuit = AppState.getActiveCircuit();
                if (!circuit) { DOMElements.markersLayer.innerHTML = ''; return; }
                let html = '';
                const { activeTurnIndex, isGlobalView, allNotes, isPlacingTurns } = AppState;

                circuit.turns.forEach((turn, i) => {
                    html += this.createMarkerHTML({
                        type: 'turn', x: turn.x, y: turn.y, value: i + 1, turnIndex: i,
                        isActive: activeTurnIndex === i,
                        isGlobal: isGlobalView,
                        isPlacing: isPlacingTurns
                    });
                });

                Object.values(allNotes).forEach(note => {
                    Object.entries(note).forEach(([type, data]) => {
                        if (markerTypes[type] && data && typeof data === 'object' && data.x !== undefined) {
                            html += this.createMarkerHTML({
                                type: type, x: data.x, y: data.y, value: data.value,
                                turnIndex: note.turnIndex,
                                isActive: activeTurnIndex === note.turnIndex || isGlobalView,
                                isGlobal: isGlobalView
                            });
                        }
                    });
                });
                DOMElements.markersLayer.innerHTML = html;
            },

            populateMarkerModal() {
                const { type, turnIndex } = AppState.editingMarkerInfo;
                const note = AppState.allNotes[turnIndex]?.[type] || {};
                DOMElements.markerModalTitle.textContent = `${markerTypes[type].label} (Virage ${turnIndex + 1})`;
                DOMElements.markerNotesTextarea.value = note.notes || '';
                let content = '';
                switch (type) {
                    case 'braking':
                    case 'throttle':
                        const labels = intensityLabels[type];
                        content = Object.entries(labels).reverse().map(([v, t]) => 
                            `<button class="w-full p-3 flex items-center gap-4 rounded-lg ${note.value == v ? 'ring-2 ring-primary' : 'bg-gray-800/50'} hover:bg-gray-700/80" data-value="${v}"><span class="w-6 h-6 rounded-full ${this.getMarkerColorClass(type, v).replace('text-','bg-')}"></span>${t}</button>`
                        ).join('');
                        break;
                    case 'gear':
                        content = '<div class="grid grid-cols-3 gap-3">' + Array.from({length: 6}, (_, i) => 
                            `<button class="btn ${note.value == i+1 ? 'bg-primary text-white' : 'btn-secondary'} text-2xl aspect-square" data-value="${i+1}">${i+1}</button>`
                        ).join('') + '</div>';
                        break;
                    default:
                        content = `<p class="text-muted text-center">Ajoutez des notes ci-dessous pour ce repère.</p>`;
                        break;
                }
                DOMElements.markerModalContent.innerHTML = content;
                this.showModal(DOMElements.markerModal);
            },
            
            renderSummary() {
                const notesByTurn = Object.values(AppState.allNotes).sort((a,b) => a.turnIndex - b.turnIndex);
                const summaryOrder = ['braking', 'gear', 'turn_in', 'apex', 'throttle', 'exit'];
                let html = '';
                
                if(notesByTurn.length === 0) {
                    html = '<p class="text-muted text-center">Aucun repère n\'a été placé pour ce circuit.</p>';
                } else {
                    notesByTurn.forEach(note => {
                        html += `<div class="p-4 bg-surface/80 rounded-lg border border-border-color"><h3 class="text-xl text-primary border-b border-border-color pb-3 mb-4 font-mono">Virage ${note.turnIndex + 1}</h3><dl class="space-y-3">`;
                        
                        summaryOrder.forEach(type => {
                            if (note[type] && typeof note[type] === 'object') {
                                const data = note[type];
                                let valueText = '';
                                if(data.value) {
                                    if(type === 'gear') valueText = `Rapport ${data.value}`;
                                    else if(intensityLabels[type]) valueText = intensityLabels[type][data.value];
                                }
                                html += `<div class="grid grid-cols-3 gap-4 items-start">
                                    <dt class="font-semibold text-gray-400">${markerTypes[type].label}</dt>
                                    <dd class="col-span-2 text-gray-200">
                                        ${valueText ? `<p class="font-semibold">${valueText}</p>` : ''}
                                        ${data.notes ? `<p class="text-sm text-muted">${data.notes}</p>` : ''}
                                        ${!valueText && !data.notes ? '<i class="text-muted">Placé</i>' : ''}
                                    </dd>
                                </div>`;
                            }
                        });
                        html += `</dl></div>`;
                    });
                }
                DOMElements.summaryContent.innerHTML = html;
                this.showModal(DOMElements.summaryModal);
            },

            updateUI() {
                this.renderCircuitsList();
                this.renderActiveCircuit();
                this.renderToolbox();
                this.renderMarkers();
                
                DOMElements.editTurnsBtn.classList.toggle('bg-primary', AppState.isPlacingTurns);
                DOMElements.editTurnsBtn.classList.toggle('text-white', AppState.isPlacingTurns);
                DOMElements.editTurnsBtn.textContent = AppState.isPlacingTurns ? "Terminer le Placement" : "Modifier les Virages";
                
                const isToolboxVisible = !AppState.isPlacingTurns && AppState.activeCircuitId;
                DOMElements.toolbox.classList.toggle('hidden', !isToolboxVisible);
                if (isToolboxVisible) {
                    if (AppState.activeTurnIndex !== null) {
                        DOMElements.activeTurnDisplay.innerHTML = `<h3 class="text-lg text-primary font-mono">Virage ${AppState.activeTurnIndex + 1}</h3><p class="text-xs text-muted">Choisissez un repère</p>`;
                        DOMElements.toolboxGrid.classList.remove('opacity-25', 'pointer-events-none');
                    } else {
                        DOMElements.activeTurnDisplay.innerHTML = `<p class="text-muted text-center text-sm">Sélectionnez un virage sur la carte.</p>`;
                        DOMElements.toolboxGrid.classList.add('opacity-25', 'pointer-events-none');
                    }
                }
                
                const toggle = DOMElements.globalViewToggle;
                const toggleBg = toggle.querySelector('.toggle-bg');
                const toggleHandle = toggle.querySelector('div > div');
                if (AppState.isGlobalView) {
                    toggleBg.classList.remove('bg-gray-700');
                    toggleBg.classList.add('bg-primary');
                    toggleHandle.classList.add('translate-x-6');
                } else {
                    toggleBg.classList.remove('bg-primary');
                    toggleBg.classList.add('bg-gray-700');
                    toggleHandle.classList.remove('translate-x-6');
                }
                
                DOMElements.mapWrapper.classList.toggle('placing-marker-mode', !!AppState.placingMarkerType);
            }
        };

        // ===================================================================================
        // --- 5. LOGIQUE D'INTERACTIONS (DRAG & DROP, CLICS) ---
        // ===================================================================================

        const Interactions = {
            dragTarget: null,
            
            getRelativeCoords(event) {
                const rect = DOMElements.mapWrapper.getBoundingClientRect();
                const clientX = event.clientX || event.touches[0].clientX;
                const clientY = event.clientY || event.touches[0].clientY;
                const x = ((clientX - rect.left) / rect.width) * 100;
                const y = ((clientY - rect.top) / rect.height) * 100;
                return { x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) };
            },

            onDragStart(event) {
                const target = event.target.closest('.marker');
                if (!target) return;
                if (target.dataset.type === 'turn' && !AppState.isPlacingTurns) return;
                
                event.preventDefault();
                this.dragTarget = target;
                AppState.setState({ isDragging: true });
                this.dragTarget.style.zIndex = 1000;
            },

            onDragMove(event) {
                if (!this.dragTarget) return;
                event.preventDefault();
                const { x, y } = this.getRelativeCoords(event);
                this.dragTarget.style.left = `${x}%`;
                this.dragTarget.style.top = `${y}%`;
            },

            async onDragEnd(event) {
                if (!this.dragTarget) return;
                const { x, y } = this.getRelativeCoords(event);
                const { type, turnIndex: turnIndexStr } = this.dragTarget.dataset;
                const turnIndex = parseInt(turnIndexStr);

                if (type === 'turn') {
                    const circuit = AppState.getActiveCircuit();
                    circuit.turns[turnIndex] = { x, y };
                    await FirebaseAPI.updateCircuitTurns(circuit.id, circuit.turns);
                } else {
                    const existingNote = AppState.allNotes[turnIndex]?.[type] || {};
                    const newNoteData = { ...existingNote, x, y };
                    await FirebaseAPI.updateTurnNote(AppState.activeCircuitId, turnIndex, { [type]: newNoteData });
                }
                const allNotes = await FirebaseAPI.getAllNotesForCircuit(AppState.activeCircuitId);
                AppState.setState({ allNotes, isDragging: false });
                this.dragTarget.style.zIndex = 'auto';
                this.dragTarget = null;
            },

            async handleMapClick(event) {
                if (AppState.isDragging) return;
                const marker = event.target.closest('.marker');

                if (marker) {
                    const { type, turnIndex: turnIndexStr } = marker.dataset;
                    const turnIndex = parseInt(turnIndexStr);
                    if (type === 'turn') {
                        AppState.setState({ 
                            activeTurnIndex: AppState.activeTurnIndex === turnIndex ? null : turnIndex,
                            isPlacingTurns: false,
                            placingMarkerType: null
                        });
                    } else {
                        AppState.setState({ editingMarkerInfo: { type, turnIndex } });
                        UI.populateMarkerModal();
                    }
                    return;
                }
                
                const { x, y } = this.getRelativeCoords(event);
                
                if (AppState.isPlacingTurns) {
                    const circuit = AppState.getActiveCircuit();
                    circuit.turns.push({ x, y });
                    await FirebaseAPI.updateCircuitTurns(circuit.id, circuit.turns);
                    AppState.setState({ activeTurnIndex: circuit.turns.length - 1 });
                } else if (AppState.placingMarkerType && AppState.activeTurnIndex !== null) {
                    const type = AppState.placingMarkerType;
                    const turnIndex = AppState.activeTurnIndex;
                    AppState.setState({ editingMarkerInfo: { type, turnIndex, x, y } });
                    UI.populateMarkerModal();
                }
            },
            
            init() {
                const mapContainer = DOMElements.mapWrapper;
                mapContainer.addEventListener('mousedown', this.onDragStart.bind(this));
                document.addEventListener('mousemove', this.onDragMove.bind(this));
                document.addEventListener('mouseup', this.onDragEnd.bind(this));
                mapContainer.addEventListener('touchstart', this.onDragStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.onDragMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.onDragEnd.bind(this));
                mapContainer.addEventListener('click', this.handleMapClick.bind(this));
            }
        };

        // ===================================================================================
        // --- 6. POINT D'ENTRÉE PRINCIPAL DE L'APPLICATION (MAIN) ---
        // ===================================================================================
        
        function addEventListeners() {
            DOMElements.circuitsList.addEventListener('click', async (e) => {
                const item = e.target.closest('.circuit-item');
                if (item && item.dataset.id !== AppState.activeCircuitId) {
                    const circuitId = item.dataset.id;
                    const allNotes = await FirebaseAPI.getAllNotesForCircuit(circuitId);
                    AppState.setState({
                        activeCircuitId: circuitId, allNotes, activeTurnIndex: null,
                        isPlacingTurns: false, placingMarkerType: null
                    });
                }
            });

            DOMElements.newCircuitBtn.addEventListener('click', () => {
                DOMElements.formNewCircuit.reset();
                UI.showModal(DOMElements.newCircuitModal);
            });
            DOMElements.editTurnsBtn.addEventListener('click', () => {
                AppState.setState({ isPlacingTurns: !AppState.isPlacingTurns, placingMarkerType: null, activeTurnIndex: null });
            });
            DOMElements.globalViewToggle.addEventListener('click', () => {
                AppState.setState({ isGlobalView: !AppState.isGlobalView });
            });
            DOMElements.summaryBtn.addEventListener('click', () => UI.renderSummary());
            
            DOMElements.formNewCircuit.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = DOMElements.formNewCircuit.querySelector('#circuit-name').value;
                const file = DOMElements.formNewCircuit.querySelector('#circuit-image-upload').files[0];
                if (!name || !file) return;
                
                const newCircuit = await FirebaseAPI.createCircuit(name, file);
                AppState.setState({
                    circuits: [...AppState.circuits, newCircuit],
                    activeCircuitId: newCircuit.id,
                    allNotes: {},
                });
                UI.hideAllModals();
            });
            
            DOMElements.toolboxGrid.addEventListener('click', (e) => {
                const btn = e.target.closest('.toolbox-item');
                if (btn) {
                    const type = btn.dataset.type;
                    AppState.setState({
                        placingMarkerType: AppState.placingMarkerType === type ? null : type
                    });
                }
            });

            DOMElements.markerModalContent.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-value]');
                if (btn) {
                    let note = AppState.allNotes[AppState.editingMarkerInfo.turnIndex]?.[AppState.editingMarkerInfo.type] || {};
                    note.value = btn.dataset.value;
                    const {type, turnIndex} = AppState.editingMarkerInfo;
                    if(!AppState.allNotes[turnIndex]) AppState.allNotes[turnIndex] = {};
                    if(!AppState.allNotes[turnIndex][type]) AppState.allNotes[turnIndex][type] = {};
                    AppState.allNotes[turnIndex][type].value = btn.dataset.value;

                    UI.populateMarkerModal();
                }
            });

            DOMElements.btnSaveMarker.addEventListener('click', async () => {
                const { type, turnIndex, x, y } = AppState.editingMarkerInfo;
                const valueEl = DOMElements.markerModalContent.querySelector('[data-value].ring-2') || DOMElements.markerModalContent.querySelector('.btn-primary');
                const value = valueEl ? valueEl.dataset.value : undefined;
                const notes = DOMElements.markerNotesTextarea.value;
                
                const existingNote = AppState.allNotes[turnIndex]?.[type] || {};
                const newNoteData = {
                    ...existingNote,
                    notes: notes,
                    ...(value !== undefined && { value }),
                    ...(x !== undefined && { x, y }),
                };

                await FirebaseAPI.updateTurnNote(AppState.activeCircuitId, turnIndex, { [type]: newNoteData });
                const allNotes = await FirebaseAPI.getAllNotesForCircuit(AppState.activeCircuitId);
                AppState.setState({ allNotes, editingMarkerInfo: null, placingMarkerType: null });
                UI.hideAllModals();
            });

            DOMElements.btnDeleteMarker.addEventListener('click', async () => {
                if(confirm("Êtes-vous sûr de vouloir supprimer ce repère ?")) {
                    const { type, turnIndex } = AppState.editingMarkerInfo;
                    await FirebaseAPI.deleteMarkerFromNote(AppState.activeCircuitId, turnIndex, type);
                    const allNotes = await FirebaseAPI.getAllNotesForCircuit(AppState.activeCircuitId);
                    AppState.setState({ allNotes, editingMarkerInfo: null });
                    UI.hideAllModals();
                }
            });

            document.querySelectorAll('.btn-cancel').forEach(btn => btn.addEventListener('click', () => {
                AppState.setState({ editingMarkerInfo: null, placingMarkerType: null });
                UI.hideAllModals();
            }));
        }
        
        async function main() {
            const userId = await connectAnonymously();
            if (!userId) return;
            AppState.setState({ userId });
            
            const circuits = await FirebaseAPI.getUserCircuits();
            AppState.setState({ circuits });

            AppState.onChange(() => UI.updateUI());
            Interactions.init();
            addEventListeners();
            
            UI.updateUI();
        }

        document.addEventListener('DOMContentLoaded', main);

    </script>
</body>
</html>
